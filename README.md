# light-lodash

--- 

Легковесная библиотека утилит для JavaScript, включающая популярные функции из Lodash(и не только). Она предоставляет только самые необходимые методы, чтобы минимизировать размер зависимостей и упростить решение повседневных задач.

--- 

## Установка
NPM: 
```bash 
npm install light-lodash
```

YARN:
```bash 
yarn add light-lodash
```

После установки вы можете импортировать необходимые функции:
```js
import { isEmpty, get } from 'light-lodash';
// или для CommonJS:
const { isEmpty, get } = require('light-lodash');
```

## Доступные функции

### isEmpty
Определяет, является ли значение пустым. Возвращает ```true```, если:
- объект не имеет собственных свойств;
- массив или строка имеют длину 0;
- коллекция типа Map или Set не содержит элементов;
- значение null или undefined (они считаются пустыми);
В остальных случаях значение не считается пустым (функция вернёт false).

Пример использования:
```js
isEmpty([]);               // true, пустой массив
isEmpty({});               // true, пустой объект
isEmpty({ a: 1 });         // false, объект имеет свойство
isEmpty('');               // true, пустая строка
isEmpty('hello');          // false, непустая строка
isEmpty(0);                // false (число не является коллекцией)
isEmpty(null);             // true
```

### get
Безопасно получает вложенное значение из объекта по указанному пути. Принимает объект, строку пути (с точечной нотацией или массивом ключей) и необязательное значение по умолчанию. Если значение по заданному пути отсутствует, вернёт указанное значение по умолчанию (или undefined, если оно не передано). 

Пример использования:
```js
const obj = { user: { name: 'Alice', info: { age: 30 } } };

get(obj, 'user.name');            // 'Alice'
get(obj, 'user.info.age');        // 30
get(obj, 'user.info.job', 'нет данных'); // 'нет данных' (путь 'user.info.job' не существует)
```

###isString
Проверяет, является ли переданное значение строкой (тип "string"). 

Пример использования:
```js
isString('Привет');    // true
isString('');          // true (пустая строка тоже строка)
isString(123);         // false
isString(true);        // false
isString({});          // false
```

### isObject
Проверяет, является ли значение объектом. Возвращает ```true```, если значение не ```null``` и его тип ```(typeof)``` равен ```'object'```. Учтите, что массивы ```(Array)``` в JavaScript имеют тип 'object', поэтому для них isObject также вернёт ```true```. Для null функция возвращает ```false```.

Пример использования:
```js
isObject({});           // true
isObject({ a: 1 });     // true
isObject([1, 2, 3]);    // true (массив тоже объект в JS)
isObject(null);         // false (null не является объектом)
isObject('текст');      // false
```

### isArray
Определяет, является ли значение массивом (Array). 

Пример использования:
```js
isArray([1, 2, 3]);    // true
isArray([]);           // true
isArray('ABC');        // false
isArray({ 0: 'a', 1: 'b' }); // false (объект, не массив)
```

### intersection
Возвращает новый массив, содержащий элементы, общие для всех переданных массивов. Сравнение производится по строгому равенству ```(===)```. 

Пример использования:
```js
intersection([1, 2, 3], [2, 3, 4]);          // [2, 3]
intersection(['a', 'b', 'c'], ['b', 'c', 'd'], ['b', 'c', 'e']); // ['b', 'c']
intersection([1, 2], [3, 4]);               // [] (нет общих элементов)
```

### cx
Объединяет CSS-классы в одну строку с учётом условий. Принимает произвольное количество аргументов (строки классов, выражения и т.д.) и возвращает строку, содержащую все переданные классы, кроме тех, которые являются пустыми или ложными значениями. Удобно для условного добавления классов (например, в React/JSX). 

Пример использования:
```js
cx('btn', isActive && 'btn--active', hasIcon ? 'has-icon' : '');
// Вернёт: "btn btn--active", если isActive === true и hasIcon === false.

cx('foo', false && 'bar', 'baz');
// Вернёт: "foo baz" (класс "bar" не добавится, т.к. выражение false && 'bar' равно false).
```

### has
Проверяет, содержит ли объект указанный вложенный ключ или путь. Возвращает ```true```, если значение по заданному пути существует (не является ```undefined```). 

Пример использования:
```js
const obj = { a: { b: 2 } };

has(obj, 'a');        // true (свойство 'a' существует)
has(obj, 'a.b');      // true (свойство b внутри a существует)
has(obj, 'a.x');      // false (у объекта a нет свойства 'x')
has(obj, 'a.b.c');    // false (у объекта a.b нет свойства 'c')
```

### pickBy
Создает новый объект, выбирая из исходного только те пары ключ-значение, для которых заданная функция-предикат возвращает ```true```. Перебор происходит по собственным свойствам объекта; предикат вызывается с аргументами (значение, ключ) для каждого свойства. 

Пример использования:
```js
const user = { name: 'Alice', age: 25, active: true };

const onlyNumbers = pickBy(user, (value, key) => typeof value === 'number');
// onlyNumbers -> { age: 25 } (выбраны только свойства со значением числа)

const startsWithA = pickBy(user, (value, key) => key.startsWith('a'));
// startsWithA -> { age: 25, active: true } (выбраны свойства, ключ которых начинается с "a")
```

### isEqual
Выполняет глубокое сравнение двух значений на равенство. Рекурсивно проверяет объекты и массивы, сравнивая вложенные данные. Возвращает ```true```, если обе структуры эквивалентны по содержимому.

Пример использования:
```js
isEqual([1, { x: 2 }], [1, { x: 2 }]);               // true (вложенные объекты эквивалентны)
isEqual({ a: 1, b: 2 }, { b: 2, a: 1 });             // true (свойства совпадают, порядок не важен)
isEqual([1, 2], [1, 2, 3]);                          // false (разная длина массивов)
isEqual({ x: 5 }, { x: 5, y: undefined });           // false (во втором объекте есть лишнее свойство y)
```

### difference
Возвращает новый массив, содержащий элементы первого массива, которые отсутствуют во всех остальных предоставленных массивах. Сравнение выполняется по строгому равенству ```(===)```. 

Пример использования:
```js
difference([1, 2, 3], [2, 4]);                   // [1, 3] (убраны элементы, присутствующие во втором массиве)
difference(['a', 'b', 'c'], ['b', 'd'], ['c']);   // ['a'] (убраны элементы, встречающиеся в последующих массивах)
difference([1, 2], [1, 2], [1, 2]);              // [] (все элементы первого массива присутствуют в остальных)
```

### debounce
Создает функцию, которая откладывает выполнение указанного действия на заданное время задержки ```(delay)```. Это полезно для ограничения частоты вызова функций (например, обработчиков ввода или событий ```resize```). Оригинальная функция будет выполнена только спустя ```delay``` миллисекунд после последнего вызова обёрнутой функции. 

Пример использования:
```js
const fn = debounce(() => console.log('Выполнено!'), 1000);

fn();
fn();
fn();
// Вызвали fn три раза подряд. Благодаря debounce, console.log выполнится только один раз через 1 секунду после последнего вызова fn().

```

# Лицензия MIT